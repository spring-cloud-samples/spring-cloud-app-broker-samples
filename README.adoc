= Spring Cloud App Broker Samples


== Parameters transformers

One of the very first things every broker will need to do is handle user input parameters.
For that, `spring-cloud-app-broker` comes with two `parameter-transformer` out of the box and a mechanism to implement your own:

[source, yml, indent=0]
----
parameters-transformers:
  - name: EnvironmentMapping
    args:
      include: lang
  - name: PropertyMapping
    args:
      include: count,upgrade,memory
  - name: RequestTimeoutParameterTransformer
----

The first transformer is `PropertyMapping` where we can specify some deployment properties. We included three properties:
`count` to allow our backing app to be scaled
`upgrade` to upgrade the backing app to a new version
`memory` to modify the default memory used by the backing app

A full list of supported properties can be found in:
https://docs.spring.io/spring-cloud-app-broker/docs/current/reference/html5/#_properties_configuration

The second transformer is `EnvironmentMapping`, where we can list which properties we want to be passed from parameters to environment variables in the backing app.

It is typical that we want to have some business logic on the way we handle the parameters, for that, we can create our own `ParameterTransformer`.
On this example, we created a custom `RequestTimeoutParameterTransformer` where we are going to map a parameter from `request-timeout-ms` to an environment variable `my-app.httpclient.connect-timeout`.

To achieve that we have to create our class:

[source, java, indent=0]
----
public class RequestTimeoutParameterTransformer extends ParametersTransformerFactory<BackingApplication, Object> {

        @Override
        public ParametersTransformer<BackingApplication> create(Object config) {
                return this::transform;
        }

        private Mono<BackingApplication> transform(
                BackingApplication backingApplication, Map<String, Object> parameters) {
                if (parameters.containsKey("request-timeout-ms")) {
                        backingApplication
                                .addEnvironment("my-app.httpclient.connect-timeout", parameters.get("request-timeout-ms"));
                        parameters.remove("request-timeout-ms");
                }
                return Mono.just(backingApplication);
        }

}
----

And then register it as a bean:
[source, java, indent=0]
----
@Bean
public ParametersTransformerFactory<BackingApplication, Object> requestTimeoutParameterTransformerFactory() {
        return new RequestTimeoutParameterTransformer();
}
----

== Creating workflows

With the default configuration, `spring-cloud-app-broker` handles the implementation of the basic operations a broker can handle: create, update, delete, bind, and unbind.
However, there are going to be times where we want to perform actions before or after some of those operations.
To help with that, `spring-cloud-app-broker` provides `https://docs.spring.io/spring-cloud-app-broker/docs/current/reference/html5/#_creating_a_service_instance[Workflows]`.
Every Workflow can have an `@Order` associated with it so that we can decide when to execute it.

A good practice is to keep the order in the same class so that we can easily read the order of all our workflows.

We created one for Service Instances:

[source,java,indent=0]
----
public class ServiceInstanceServiceOrder {
    private static final int CREATE_SI_WORKFLOW_ORDER = 0;

	public static final int VALIDATE_CREATE_PARAMETERS = CREATE_SI_WORKFLOW_ORDER - 400;
}
----

An example of Workflow that runs before creating a Service Instance is validating the parameters:

[source,java,indent=0]
----
@Component
@Order(VALIDATE_CREATE_PARAMETERS)
public class ServiceInstanceParametersValidatorWorkflow implements CreateServiceInstanceWorkflow {

	private static final String SERVICE_NAME = "example";

	private static final List<String> SUPPORTED_PARAMETERS = Arrays.asList("count", "memory", "routes"); // TODO java 14

	@Override
	public Mono<Boolean> accept(CreateServiceInstanceRequest request) {
		return Mono.just(SERVICE_NAME.equals(request.getServiceDefinition().getName()));
	}

	@Override
	public Mono<CreateServiceInstanceResponseBuilder> buildResponse(
		CreateServiceInstanceRequest request,
		CreateServiceInstanceResponseBuilder responseBuilder) {

		for (String parameter : request.getParameters().keySet()) {
			if (!SUPPORTED_PARAMETERS.contains(parameter)) {
				String errorMessage = String.format("Invalid parameter {%s}", parameter);
				return Mono.error(new ServiceBrokerInvalidParametersException(errorMessage));
			}
		}

		return Mono.just(responseBuilder);
	}

}
----
